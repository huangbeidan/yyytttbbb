package Utilities;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static java.lang.Math.max;
import static java.lang.Math.min;
import static Utilities.Math.max;


import SimilarityScore.MatchMismatchWords;
import SimilarityScore.SMITHW;
import SimilarityScore.StringMetricWords;
import SimilarityScore.SubstitutionWords;
import org.simmetrics.StringMetric;
import org.simmetrics.metrics.functions.AffineGap;
import org.simmetrics.metrics.functions.Gap;


import org.simmetrics.metrics.functions.Substitution;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;


public final class SmithWatermanWords implements StringMetricWords {

    private final Gap gap;
    private final SubstitutionWords substitutionWords;
    private final int windowSize;
    float[][] d;

    /**
     * Constructs a new Smith Waterman metric. Uses an affine gap of
     * <code>-5.0 - gapLength</code> a <code>-3.0</code> substitution penalty
     * for mismatches, <code>5.0</code> for matches.
     *
     */
    public SmithWatermanWords() {
        this(new AffineGap(-3.0f, -1.0f), new MatchMismatchWords(3.0f, -3.0f),
                Integer.MAX_VALUE);
    }

    /**
     * Constructs a new Smith Waterman metric.
     *
     * @param gap
     *            a gap function to score gaps by
     * @param substitutionWords
     *            a substitution function to score substitutions by
     * @param windowSize
     *            a non-negative window in which
     */
    public SmithWatermanWords(Gap gap, SubstitutionWords substitutionWords, int windowSize) {
        checkNotNull(gap);
        checkNotNull(substitutionWords);
        checkArgument(windowSize >= 0);
        this.gap = gap;
        this.substitutionWords = substitutionWords;
        this.windowSize = windowSize;
    }

    @Override
    public float compare(String[] a, String[] b) {

        if (a.length==0 && b.length==0) {
            return 1.0f;
        }
        if (a.length==0 || b.length==0) {
            return 0.0f;
        }
        float maxDistance = min(a.length, b.length)
                * max(substitutionWords.max(), gap.min());
        return smithWaterman(a, b).getMax() / maxDistance;

        /** the score is measured by smithWaterman score (e.g. 16) / maxDistance (min length * max(penalty or matchvalue) */

    }



    private SMITHW smithWaterman(String[] a, String[] b) {
        final int n = a.length;
        final int m = b.length;

         d = new float[n][m];

        // Initialize corner
        float max = d[0][0] = max(0, substitutionWords.compare(a, 0, b, 0));

        // Initialize edge
        for (int i = 0; i < n; i++) {

            // Find most optimal deletion
            float maxGapCost = 0;
            for (int k = max(1, i - windowSize); k < i; k++) {
                maxGapCost = max(maxGapCost, d[i - k][0] + gap.value(i - k, i));
            }

            d[i][0] = max(0, maxGapCost, substitutionWords.compare(a, i, b, 0));

            max = max(max, d[i][0]);

        }

        // Initialize edge
        for (int j = 1; j < m; j++) {

            // Find most optimal insertion
            float maxGapCost = 0;
            for (int k = max(1, j - windowSize); k < j; k++) {
                maxGapCost = max(maxGapCost, d[0][j - k] + gap.value(j - k, j));
            }

            d[0][j] = max(0, maxGapCost, substitutionWords.compare(a, 0, b, j));

            max = max(max, d[0][j]);

        }

        // Build matrix
        for (int i = 1; i < n; i++) {

            for (int j = 1; j < m; j++) {

                float maxGapCost = 0;
                // Find most optimal deletion
                for (int k = max(1, i - windowSize); k < i; k++) {
                    maxGapCost = max(maxGapCost,
                            d[i - k][j] + gap.value(i - k, i));
                }
                // Find most optimal insertion
                for (int k = max(1, j - windowSize); k < j; k++) {
                    maxGapCost = max(maxGapCost,
                            d[i][j - k] + gap.value(j - k, j));
                }

                // Find most optimal of insertion, deletion and substitution
                d[i][j] = max(0, maxGapCost,
                        d[i - 1][j - 1] + substitutionWords.compare(a, i, b, j));

                max = max(max, d[i][j]);
            }

        }


//        for (int i = 0; i < d.length; i++) {
//            for (int j = 0; j < d[i].length; j++) {
//                System.out.print(d[i][j] + " ");
//            }
//            System.out.println();
//        }

        return new SMITHW(d,max);
    }

    /** get the optimized route
     *
     * @return
     */

    public LinkedList<int[]> getRoute(float[][]d, float max){

        LinkedList<int[]> route = new LinkedList<>();

        int m  = d.length, n=d[0].length;

        int row = m-1, col = n-1;
        //search for the max
        int[] track = new int[]{0,0};
        track = searchMax(d,max,row,col,track);

        System.out.println("row is" + track[0] + "col is: "+track[1]);

       //search neighbor to find the next to go
        searchNeighbor(route,d,track[0],track[1]);

        return route;
    }

    public int[] searchMax(float[][] d, float max, int row, int col, int[] track){

        if(row <0 || col<0) return track;

        if(d[row][col] == max){
            track = new int[]{row,col};
            System.out.println("Row is: "+row + "Col is: "+col + "track is " + track[0]+track[1]);
            return track;

        }

        searchMax(d,max,row-1,col,track);
        searchMax(d,max,row,col-1,track);
        searchMax(d,max,row-1,col-1,track);

        return track;

    }

    public void searchNeighbor(LinkedList<int[]> map, float[][]d, int row, int col){


        if(row<0 || col<0) return;

        map.add(new int[]{row,col});

        if(row==0 && col==0) return;

        int[] temp = (row>0 && col>0) ? new int[]{row-1,col-1} : (row>0) ? new int[]{row-1,col} : (col>0) ? new int[]{row,col-1} : new int[]{0,0};


        if(col-1>=0 && d[row][col-1]>d[temp[0]][temp[1]]){
            temp = new int[]{row,col-1};
        }

        if(row-1>=0 && d[row-1][col] > d[temp[0]][temp[1]]){
            temp = new int[]{row-1,col};
        }

        searchNeighbor(map,d,temp[0],temp[1]);

    }

    public void getRoutehelper (LinkedList<int[]> map, float[][]d, float max, int i, int j){


        int m = d.length, n=d[0].length;

        if(i>=m || j>=n || i<0 || j<0) return;

        map.add(new int[]{i,j});

        if(d[i][j]==max)return;

        if(i<m-1 && j<n-1 && d[i+1][j+1]>=d[i][j]){
            getRoutehelper(map,d,max,i+1,j+1);

        }else
        {
            if(i<m-1 && d[i+1][j] !=0){
                getRoutehelper(map,d,max,i+1,j);
                map.remove(map.size()-1);
            }
            if( j<n-1 && d[i][j+1] !=0)
               { getRoutehelper(map,d,max,i,j+1);
               map.remove(map.size()-1);
               }
           }

        }



    @Override
    public String toString() {
        return "SmithWatermanWords [gap=" + gap + ", substitution=" + substitutionWords
                + ", windowSize=" + windowSize + "]";
    }

    public static void main(String[] args){
        SmithWatermanWords smithWatermanWords = new SmithWatermanWords();
        String one = "New Zealand’s Gun Laws Draw Scrutiny After Mosque Shootings";
        String two = "New Zealand’s abd eee ccc fff ggg aaa Shootings";
        String three = "Gun Laws In New Zealand Draw Scrutiny After Mosque Shootings";
        String[] a = one.split(" ");
        String[] b = three.split(" ");
//        System.out.println(smithWatermanWords.compare(a,b));
//        System.out.println(smithWatermanWords.smithWaterman(a,b));
//        System.out.println(smithWatermanWords.toString());
        SMITHW smithw = smithWatermanWords.smithWaterman(a,b);
        float[][] d = smithw.getMatrix();
                for (int i = 0; i < d.length; i++) {
            for (int j = 0; j < d[i].length; j++) {
                System.out.print(d[i][j] + " ");
            }
            System.out.println();
        }
        float max = (smithw.getMax());
                System.out.println("max is: "+max);

        LinkedList<int[]> route = smithWatermanWords.getRoute(d,max);
        for(int[] pair: route){
            System.out.println(pair[0] + "  " + pair[1]);
        }

    }

}